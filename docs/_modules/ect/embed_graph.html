

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ect.embed_graph &mdash; ect 0.1.5 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />

  
    <link rel="shortcut icon" href="../../_static/ECT_Logo_128x128.png"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=59fadc99"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #cececf" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ect
              <img src="../../_static/ECT_Logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">1. Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#prerequisites">1.1. Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installing-ect">1.2. Installing <cite>ect</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#uninstalling-ect">1.3. Uninstalling <cite>ect</cite></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">2. Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../embed_graph.html">2.1. Embedded graphs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph"><code class="docutils literal notranslate"><span class="pre">EmbeddedGraph</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../embed_graph.html#ect.embed_graph.create_example_graph"><code class="docutils literal notranslate"><span class="pre">create_example_graph()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../embed_cw.html">2.2. Embedded CW complex</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../embed_cw.html#ect.embed_cw.EmbeddedCW"><code class="docutils literal notranslate"><span class="pre">EmbeddedCW</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../embed_cw.html#ect.embed_cw.create_example_cw"><code class="docutils literal notranslate"><span class="pre">create_example_cw()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ect_on_graphs.html">2.3. ECT on graphs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ect_on_graphs.html#ect.ect_graph.ECT"><code class="docutils literal notranslate"><span class="pre">ECT</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">3. Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/Tutorial-ECT_for_embedded_graphs.html">3.1. Tutorial : ECT for embedded graphs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../notebooks/Tutorial-ECT_for_embedded_graphs.html#Constructing-the-embedded-graph">3.1.1. Constructing the embedded graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../notebooks/Tutorial-ECT_for_embedded_graphs.html#Computing-the-ECT-of-G">3.1.2. Computing the ECT of <span class="math notranslate nohighlight">\(G\)</span></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../notebooks/Tutorial-ECT_for_embedded_graphs.html#SECT">3.1.3. SECT</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/Tutorial-ECT_for_CW_Complexes.html">3.2. Tutorial: ECT for CW complexes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/Matisse/Matisse_ECT.html">3.3. ECT on Matisse’s “The Parakeet and the Mermaid”</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../notebooks/Matisse/Matisse_ECT.html#Acknowledgements">3.3.1. Acknowledgements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../notebooks/Tutorial-ExactECT.html">3.4. Tutorial for exact ECT computation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">4. Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../contributing.html#getting-started">4.1. Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing.html#contributing-guidelines">4.2. Contributing Guidelines</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../contributing.html#code-style-and-formatting">4.2.1. Code style and formatting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../contributing.html#documentation-guidelines">4.2.2. Documentation guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../contributing.html#testing-guidelines">4.2.3. Testing guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../contributing.html#issue-tracking-and-pull-requests">4.2.4. Issue tracking and pull requests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing.html#conclusion">4.3. Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">5. License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../citing.html">6. Citing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #cececf" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ect</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ect.embed_graph</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ect.embed_graph</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>  <span class="c1"># for PCA for normalization</span>


<div class="viewcode-block" id="EmbeddedGraph">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph">[docs]</a>
<span class="k">class</span> <span class="nc">EmbeddedGraph</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to represent a graph with 2D embedded coordinates for each vertex.</span>

<span class="sd">    Attributes</span>
<span class="sd">        graph : nx.Graph</span>
<span class="sd">            a NetworkX graph object</span>
<span class="sd">        coordinates : dict</span>
<span class="sd">            a dictionary mapping vertices to their (x, y) coordinates</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="EmbeddedGraph.__init__">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes an empty EmbeddedGraph object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="p">{}</span></div>


<div class="viewcode-block" id="EmbeddedGraph.add_node">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.add_node">[docs]</a>
    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a vertex to the graph. </span>
<span class="sd">        If the vertex name is given as None, it will be assigned via the ``next_vert_name`` method.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            vertex (hashable like int or str, or None) : The name of the vertex to add.</span>
<span class="sd">            x, y (floats) : The function value of the vertex being added.</span>
<span class="sd">            reset_pos (bool, optional) </span>
<span class="sd">                If True, will reset the positions of the nodes based on the function values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;The vertex name </span><span class="si">{</span><span class="n">vertex</span><span class="si">}</span><span class="s1"> is already used in the graph.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vertex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">vertex</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_vert_name</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmbeddedGraph.add_nodes_from">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.add_nodes_from">[docs]</a>
    <span class="k">def</span> <span class="nf">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds multiple vertices to the graph and assigns them the given coordinates.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            nodes (list):</span>
<span class="sd">                A list of vertices to be added.</span>
<span class="sd">            coordinates (dict):</span>
<span class="sd">                A dictionary mapping vertices to their coordinates.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmbeddedGraph.next_vert_name">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.next_vert_name">[docs]</a>
    <span class="k">def</span> <span class="nf">next_vert_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">num_verts</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Making a simple name generator for vertices. </span>
<span class="sd">        If you&#39;re using integers, it will just up the count by one. </span>
<span class="sd">        Letters will be incremented in the alphabet. If you reach ``Z``, it will return ``AA``. If you reach ``ZZ``, it will return ``AAA``, etc.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            s (str or int): The name of the vertex to increment.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str or int</span>
<span class="sd">                The next name in the sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num_verts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_verts</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">num_verts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_verts</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">num_verts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;AA&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_verts</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s1">&#39;AA&#39;</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">num_verts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_verts</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="s1">&#39;A&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">num_verts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_verts</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input must be a string or an integer&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmbeddedGraph.add_edge">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.add_edge">[docs]</a>
    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an edge between the vertices u and v if they exist.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            u (str):</span>
<span class="sd">                The first vertex of the edge.</span>
<span class="sd">            v (str):</span>
<span class="sd">                The second vertex of the edge.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or both vertices do not exist in the graph.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmbeddedGraph.add_cycle">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.add_cycle">[docs]</a>
    <span class="k">def</span> <span class="nf">add_cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord_matrix</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add nodes and edges from a cycle of coordinates. </span>
<span class="sd">        Specifically, will add a node for each row and the edges connecting the nodes in the order they appear in the matrix as a closed cycle.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            coord_matrix : numpy array</span>
<span class="sd">                An (n x 2) matrix of coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_matrix</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">last_name</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last_name</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_vert_name</span><span class="p">(</span><span class="n">last_name</span><span class="p">,</span> <span class="n">num_verts</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">coord_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmbeddedGraph.get_coordinates">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.get_coordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">get_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinates of the given vertex.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            vertex (str):</span>
<span class="sd">                The vertex whose coordinates are to be returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: The coordinates of the vertex.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmbeddedGraph.set_coordinates">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.set_coordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">set_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the coordinates of the given vertex.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            vertex (str):</span>
<span class="sd">                The vertex whose coordinates are to be set.</span>
<span class="sd">            x (float):</span>
<span class="sd">                The new x-coordinate of the vertex.</span>
<span class="sd">            y (float): </span>
<span class="sd">                The new y-coordinate of the vertex.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the vertex does not exist in the graph.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Vertex does not exist in the graph.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmbeddedGraph.get_bounding_box">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.get_bounding_box">[docs]</a>
    <span class="k">def</span> <span class="nf">get_bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to find a bounding box of the vertex coordinates in the graph.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of tuples representing the minimum and maximum :math:`x` and :math:`y` coordinates.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">[(</span><span class="nb">min</span><span class="p">(</span><span class="n">x_coords</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_coords</span><span class="p">)),</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">y_coords</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_coords</span><span class="p">))]</span></div>


<div class="viewcode-block" id="EmbeddedGraph.get_center">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.get_center">[docs]</a>
    <span class="k">def</span> <span class="nf">get_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;origin&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and return the center of the graph. This can be done by either returning the average of the coordiantes (``mean``), the center of the bounding box (``min_max``), or the origin (``origin``).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            type (str): The type of center to calculate. Options are ``mean``, ``min_max``, or ``origin``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: The :math:`(x, y)` coordinates of the center.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;origin&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;min_max&#39;</span><span class="p">:</span>
            <span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_coords</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_coords</span><span class="p">)</span>
            <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_coords</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_coords</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">max_x</span><span class="o">+</span><span class="n">min_x</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">max_y</span><span class="o">+</span><span class="n">min_y</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span></div>


<div class="viewcode-block" id="EmbeddedGraph.get_bounding_radius">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.get_bounding_radius">[docs]</a>
    <span class="k">def</span> <span class="nf">get_bounding_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;origin&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to find the radius of the bounding circle of the vertex coordinates in the graph. </span>

<span class="sd">        Parameters:</span>
<span class="sd">            type (str): The type of center to calculate the radius relative to. Options are ``mean``, ``min_max``, or ``origin``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The radius of the bounding circle.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coords</span> <span class="o">-</span> <span class="n">center</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span></div>


    <span class="c1"># ------</span>
    <span class="c1"># Methods for normalizing the coordinates in various ways</span>
    <span class="c1"># ------</span>

<div class="viewcode-block" id="EmbeddedGraph.get_centered_coordinates">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.get_centered_coordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">get_centered_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;min_max&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to find the centered coordinates of the vertices in the graph.</span>

<span class="sd">        If type is ``min_max``, the coordinates are centered at the mean of the min and max values of the :math:`x` and :math:`y` coordinates.</span>
<span class="sd">        If type is ``mean``, the coordinates are centered at the mean of the :math:`x` and :math:`y` coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>


<div class="viewcode-block" id="EmbeddedGraph.set_centered_coordinates">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.set_centered_coordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">set_centered_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;min_max&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to set the centered coordinates of the vertices in the graph. Warning: This overwrites the original coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_centered_coordinates</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmbeddedGraph.get_scaled_coordinates">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.get_scaled_coordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">get_scaled_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to find the scaled coordinates of the vertices in the graph to fit in the disk centered at 0 with radius given by ``radius``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            radius (float):</span>
<span class="sd">                The radius of the bounding disk.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: A dictionary mapping vertices to their scaled coordinates.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">max_norm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">))</span>
        <span class="n">x_coords</span> <span class="o">=</span> <span class="n">x_coords</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">/</span> <span class="n">max_norm</span>
        <span class="n">y_coords</span> <span class="o">=</span> <span class="n">y_coords</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">/</span> <span class="n">max_norm</span>

        <span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">)}</span></div>


<div class="viewcode-block" id="EmbeddedGraph.set_scaled_coordinates">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.set_scaled_coordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">set_scaled_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to set the scaled coordinates of the vertices in the graph to fit in the disk centered at 0 with radius given by ``radius``. Warning: This overwrites the original coordinates</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_coordinates</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmbeddedGraph.rescale_to_unit_disk">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.rescale_to_unit_disk">[docs]</a>
    <span class="k">def</span> <span class="nf">rescale_to_unit_disk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preserve_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">center_type</span><span class="o">=</span><span class="s1">&#39;origin&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rescales the graph coordinates to fit within a radius 1 disk.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            preserve_center (bool): If True, maintains the current center point of type ``center_type``.</span>
<span class="sd">                                    If False, centers the graph at (0, 0).</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: Returns the instance for method chaining.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the graph has no coordinates or all coordinates are identical.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Graph has no coordinates to rescale.&quot;</span><span class="p">)</span>

        <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center</span><span class="p">(</span><span class="n">center_type</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="n">coords_centered</span> <span class="o">=</span> <span class="n">coords</span> <span class="o">-</span> <span class="n">center</span>

        <span class="n">max_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coords_centered</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">max_distance</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All coordinates are identical. Cannot rescale.&quot;</span><span class="p">)</span>

        <span class="n">scale_factor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">max_distance</span>

        <span class="n">new_coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords_centered</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">)</span> <span class="o">+</span> \
            <span class="p">(</span><span class="n">center</span> <span class="k">if</span> <span class="n">preserve_center</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">new_coord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">new_coords</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_coord</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="EmbeddedGraph.get_PCA_coordinates">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.get_PCA_coordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">get_PCA_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to find the PCA coordinates of the vertices in the graph.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: A dictionary mapping vertices to their PCA normalized coordinates.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

        <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># initiate PCA</span>
        <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>  <span class="c1"># fit PCA to coordinates to find longest axis</span>
        <span class="n">pca_scores</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>  <span class="c1"># retrieve PCA coordinates</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">pca_scores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)}</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="EmbeddedGraph.set_PCA_coordinates">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.set_PCA_coordinates">[docs]</a>
    <span class="k">def</span> <span class="nf">set_PCA_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to set the PCA coordinates of the vertices in the graph which is helpful for coarse alignment. </span>
<span class="sd">        If you also want to center at zero, the options for ``center_type`` are ``mean`` or ``min_max``.</span>
<span class="sd">        Set ``scale_radius`` to a value to scale to a specific radius.</span>
<span class="sd">        Warning: This overwrites the original coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_PCA_coordinates</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">center_type</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_centered_coordinates</span><span class="p">(</span><span class="n">center_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale_radius</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_scaled_coordinates</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">scale_radius</span><span class="p">)</span></div>


    <span class="c1"># ================</span>
    <span class="c1"># Functions for computing the function g(v) for vertices and edges</span>
    <span class="c1"># ================</span>

<div class="viewcode-block" id="EmbeddedGraph.g_omega">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.g_omega">[docs]</a>
    <span class="k">def</span> <span class="nf">g_omega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to compute the function :math:`g_\\omega(v)` for all vertices :math:`v` in the graph in the direction of :math:`\\theta \\in [0,2\\pi]` . This function is defined by :math:`g_\\omega(v) = \\langle \\texttt{pos}(v), \\omega \\rangle` .</span>

<span class="sd">        Parameters:</span>

<span class="sd">            theta (float):</span>
<span class="sd">                The angle in :math:`[0,2\\pi]` for the direction to compute the :math:`g(v)` values.</span>

<span class="sd">        Returns:</span>

<span class="sd">            dict: A dictionary mapping vertices to their :math:`g(v)` values.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">omega</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>

        <span class="n">g</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">omega</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span></div>


<div class="viewcode-block" id="EmbeddedGraph.g_omega_edges">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.g_omega_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">g_omega_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the function value of the edges of the graph by making the value equal to the max vertex value </span>

<span class="sd">        Parameters:</span>

<span class="sd">            theta (float): </span>
<span class="sd">                The direction of the function to be calculated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict</span>
<span class="sd">                A dictionary of the function values of the edges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_omega</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">g_edges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">g_edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">g_edges</span></div>


<div class="viewcode-block" id="EmbeddedGraph.sort_vertices">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.sort_vertices">[docs]</a>
    <span class="k">def</span> <span class="nf">sort_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">return_g</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to sort the vertices of the graph according to the function `g_omega(v)` in the direction of :math:`\\theta \\in [0,2\\pi]`.</span>

<span class="sd">        TODO: eventually, do we want this to return a sorted list of g values as well? Since we&#39;re already doing the sorting work, it might be helpful.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            theta (float):</span>
<span class="sd">                The angle in :math:`[0,2 \\pi]` for the direction to sort the vertices.</span>
<span class="sd">            return_g (bool):</span>
<span class="sd">                Whether to return the :math:`g(v)` values along with the sorted vertices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list</span>
<span class="sd">                A list of vertices sorted in increasing order of the :math:`g(v)` values. </span>
<span class="sd">                If ``return_g`` is True, also returns the ``g`` dictionary with the function values ``g[vertex_name]=func_value``. </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_omega</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">v_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">return_g</span><span class="p">:</span>
            <span class="c1"># g_sorted = [g[v] for v in v_list]</span>
            <span class="k">return</span> <span class="n">v_list</span><span class="p">,</span> <span class="n">g</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v_list</span></div>


<div class="viewcode-block" id="EmbeddedGraph.sort_edges">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.sort_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">sort_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">return_g</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to sort the edges of the graph according to the function</span>

<span class="sd">        .. math ::</span>

<span class="sd">            g_\\omega(e) = \\max \\{ g_\\omega(v) \\mid  v \in e \\}</span>

<span class="sd">        in the direction of :math:`\\theta \\in [0,2\\pi]` .</span>

<span class="sd">        Parameters:</span>
<span class="sd">            theta (float):</span>
<span class="sd">                The angle in :math:`[0,2\\pi]` for the direction to sort the edges.</span>
<span class="sd">            return_g (bool):</span>
<span class="sd">                Whether to return the :math:`g(v)` values along with the sorted edges.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of edges sorted in increasing order of the :math:`g(v)` values. </span>
<span class="sd">            If ``return_g`` is True, also returns the ``g`` dictionary with the function values ``g[vertex_name]=func_value``. </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g_e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_omega_edges</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">e_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">g_e</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">return_g</span><span class="p">:</span>
            <span class="c1"># g_sorted = [g[v] for v in v_list]</span>
            <span class="k">return</span> <span class="n">e_list</span><span class="p">,</span> <span class="n">g_e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">e_list</span></div>


<div class="viewcode-block" id="EmbeddedGraph.lower_edges">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.lower_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">lower_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to compute the number of lower edges of a vertex `v` for a specific direction (included by the use of sorted `v_list`).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            v (str):</span>
<span class="sd">                The vertex to compute the number of lower edges for.</span>
<span class="sd">            omega (tuple): </span>
<span class="sd">                The direction vector to consider given as an angle in [0, 2pi].</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The number of lower edges of the vertex v.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
        <span class="n">gv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">omega</span><span class="p">)</span>
        <span class="n">Lg</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">omega</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">L</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">gv</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">Lg</span><span class="p">)</span>  <span class="c1"># includes possible duplicate counts</span></div>


    <span class="c1"># ================</span>
    <span class="c1"># Functions for getting the angles where vertices switch order</span>
    <span class="c1"># ================</span>

<div class="viewcode-block" id="EmbeddedGraph.get_all_normals_matrix">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.get_all_normals_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_normals_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_rounding_digits</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to get all angles of normals to any line between vertices in the graph, returned as a matrix. Note this includes both adjacent vertices and non-adjacent. This function is useful for knowing the angle of the circle where two vertices switch in order. </span>

<span class="sd">        Parameters:</span>
<span class="sd">            num_rounding_digits (int):</span>
<span class="sd">                The number of digits to round the angles in the matrix. If `None`, no rounding is done. </span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple consissting of a matrix of angles, and the sorted label list for the rows/columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># Make rows of repeated copies of first column of P</span>
        <span class="n">X_Cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">P</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">X_diff</span> <span class="o">=</span> <span class="n">X_Cols</span> <span class="o">-</span> <span class="n">X_Cols</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># The x value of the vector from A to B</span>

        <span class="c1"># Make rows of repeated copies of second column of P</span>
        <span class="n">Y_Cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">P</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Y_diff</span> <span class="o">=</span> <span class="n">Y_Cols</span> <span class="o">-</span> <span class="n">Y_Cols</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Convert to float to allow NaN assignment</span>
        <span class="n">X_diff</span> <span class="o">=</span> <span class="n">X_diff</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">Y_diff</span> <span class="o">=</span> <span class="n">Y_diff</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Set diagonals to nan</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">X_diff</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">Y_diff</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">angle_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">X_diff</span><span class="p">,</span> <span class="o">-</span><span class="n">Y_diff</span><span class="p">)</span>
        <span class="c1"># Puts all entries between 0 and 2pi</span>
        <span class="n">angle_matrix</span> <span class="o">=</span> <span class="n">angle_matrix</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_rounding_digits</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">angle_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">angle_matrix</span><span class="p">,</span> <span class="n">num_rounding_digits</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">angle_matrix</span><span class="p">,</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="EmbeddedGraph.get_normals_dict">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.get_normals_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">get_normals_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">num_rounding_digits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">edges_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">opposites</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to get all angles of normals to any line between vertices in the graph, returned as a dictionary of angles with ``dict[theta]`` returning the list of pairs of vertices with vector normal to :math:`\\overrightarrow{AB}` at angle ``theta``. Note this includes both adjacent vertices and non-adjacent unless ``edges_only`` is set to ``True``. This function is useful for knowing the angle of the circle where two vertices switch in order, especially when we want to sort the events around the circle. All angles are rounded to the number of digits given by ``num_rounding_digits``, and are returned in the range :math:`[0, 2\\pi]` .</span>

<span class="sd">        Parameters:</span>
<span class="sd">            num_rounding_digits (int):</span>
<span class="sd">                The number of digits to round the angles in the dictionary. If None, no rounding is done.</span>
<span class="sd">            edges_only (bool):</span>
<span class="sd">                If True, the dictionary version only returns the angle of the normals to the lines between vertices sharing an edge. The matrix version is unchanged.</span>
<span class="sd">            opposites (bool):</span>
<span class="sd">                If True, will also include both :math:`\\theta` and :math:`\\theta + \\pi` in the dictionary keys.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: A dictionary of angles with `dict[theta]` returning the list of pairs of vertices with vector normal to :math:`\\overrightarrow\\{AB\\}` at angle `theta`, e.g. ``dict[theta] = [(&#39;A&#39;,&#39;B&#39;), (&#39;C&#39;, &#39;D&#39;)]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">angle_matrix</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all_normals_matrix</span><span class="p">(</span>
            <span class="n">num_rounding_digits</span><span class="o">=</span><span class="n">num_rounding_digits</span><span class="p">)</span>

        <span class="n">angle_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
                <span class="c1"># Skip this edge if edges_only is True and the vertices are not connected</span>
                <span class="k">if</span> <span class="n">edges_only</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">labels</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">angle_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="n">angle_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">angle_dict</span><span class="p">[</span><span class="n">angle_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">labels</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="n">angle_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">angle_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">angle_dict</span><span class="p">[</span><span class="n">angle_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">angle_dict</span><span class="p">[</span><span class="n">angle_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">labels</span><span class="p">[</span><span class="n">j</span><span class="p">])]</span>

        <span class="k">if</span> <span class="n">opposites</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">angle_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">other_key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">num_rounding_digits</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">other_key</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">other_key</span><span class="p">,</span> <span class="n">num_rounding_digits</span><span class="p">)</span>
                <span class="n">angle_dict</span><span class="p">[</span><span class="n">other_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># Make sure all keys are in the range [0, 2pi]</span>
        <span class="n">angle_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span>
                      <span class="n">value</span> <span class="ow">in</span> <span class="n">angle_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># Make sure all keys are rounded to the correct number of digits</span>
        <span class="k">if</span> <span class="n">num_rounding_digits</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">angle_dict</span> <span class="o">=</span> <span class="p">{</span><span class="nb">round</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">num_rounding_digits</span><span class="p">)</span>                          <span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">angle_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">return</span> <span class="n">angle_dict</span></div>


    <span class="c1"># ================</span>
    <span class="c1"># Plotting functions</span>
    <span class="c1"># ================</span>
<div class="viewcode-block" id="EmbeddedGraph.plot">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.plot">[docs]</a>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="n">bounding_circle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">color_nodes_theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to plot the graph with the embedded coordinates.</span>

<span class="sd">        If ``bounding_circle`` is True, a bounding circle is drawn around the graph.</span>

<span class="sd">        If ``color_nodes_theta`` is not ``None``, it should be given as a :math:`theta` in :math:`[0,2\\pi]`. Then the nodes are colored according to the :math:`g(v)` values in the direction of :math:`\\theta`.</span>

<span class="sd">        If ``with_labels`` is ``True``, the nodes are labeled with their names.</span>

<span class="sd">        If ``ax`` is not ``None``, the plot is drawn on the given axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span>
        <span class="c1"># center = self.get_center(type = &#39;min_max&#39;)</span>
        <span class="c1"># r = self.get_bounding_radius(type = &#39;min_max&#39;)</span>

        <span class="k">if</span> <span class="n">color_nodes_theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="n">with_labels</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_omega</span><span class="p">(</span><span class="n">color_nodes_theta</span><span class="p">)</span>
            <span class="n">color_map</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span>
            <span class="c1"># Some weird plotting to make the colorbar work.</span>
            <span class="n">pathcollection</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">color_map</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">pathcollection</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">labelleft</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bounding_circle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_bounding_circle</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="s1">&#39;box&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="EmbeddedGraph.plot_bounding_circle">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.plot_bounding_circle">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_bounding_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounding_center_type</span><span class="o">=</span><span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to plot the bounding circle of the graph. </span>

<span class="sd">        If ``ax`` is not None, the plot is drawn on the given axis.</span>

<span class="sd">        If ``bounding_center_type`` is &#39;origin&#39;, the bounding circle is centered at the origin. If it is ``min_max``, the bounding circle is centered at the mean of the min and max values of the :math:`x` and :math`y` coordinates.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>

        <span class="n">circle_center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center</span><span class="p">(</span><span class="n">bounding_center_type</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bounding_radius</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">bounding_center_type</span><span class="p">)</span>
        <span class="n">circle</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span><span class="n">circle_center</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>

        <span class="c1"># Always adjust the plot limits to show the full graph</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">circle_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">circle_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">circle_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">circle_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmbeddedGraph.plot_angle_circle">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.EmbeddedGraph.plot_angle_circle">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_angle_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edges_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to plot the circle of angles for the graph. </span>

<span class="sd">        Example Usage: </span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            fig, ax = plt.subplots()</span>
<span class="sd">            G.plot(ax = ax)</span>
<span class="sd">            G.plot_angle_circle(ax = ax)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>

        <span class="n">circle_center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;min_max&#39;</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mf">1.3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bounding_radius</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;min_max&#39;</span><span class="p">)</span>
        <span class="n">circle</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span><span class="n">circle_center</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>

        <span class="c1"># Get all the angles with the labels to be drawn</span>
        <span class="n">angles_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_normals_dict</span><span class="p">(</span>
            <span class="n">edges_only</span><span class="o">=</span><span class="n">edges_only</span><span class="p">,</span> <span class="n">opposites</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">angles_dict_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}{</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">value</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">angles_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># Draw hash marks on the circle</span>
        <span class="n">hash_length</span> <span class="o">=</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">r</span>  <span class="c1"># Length of the hash marks</span>
        <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">angles_dict_labels</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">x_start</span> <span class="o">=</span> <span class="n">circle_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                <span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">hash_length</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">y_start</span> <span class="o">=</span> <span class="n">circle_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                <span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">hash_length</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">x_end</span> <span class="o">=</span> <span class="n">circle_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">hash_length</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">y_end</span> <span class="o">=</span> <span class="n">circle_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">hash_length</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x_start</span><span class="p">,</span> <span class="n">x_end</span><span class="p">],</span> <span class="p">[</span><span class="n">y_start</span><span class="p">,</span> <span class="n">y_end</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>

            <span class="c1"># Add labels near the hash marks</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">label_x</span> <span class="o">=</span> <span class="n">circle_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">scaling</span> <span class="o">*</span> <span class="n">hash_length</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">label_y</span> <span class="o">=</span> <span class="n">circle_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">scaling</span> <span class="o">*</span> <span class="n">hash_length</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
            <span class="n">text_angle</span> <span class="o">=</span> <span class="n">angle</span> <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="ow">or</span> <span class="n">angle</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="k">else</span> <span class="n">angle</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">label_x</span><span class="p">,</span> <span class="n">label_y</span><span class="p">,</span>
                    <span class="n">angles_dict_labels</span><span class="p">[</span><span class="n">angle</span><span class="p">],</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">text_angle</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
        <span class="c1"># Always adjust the plot limits to show the full graph</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="mf">1.5</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">circle_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">scale_factor</span><span class="o">*</span><span class="n">r</span><span class="p">,</span>
                    <span class="n">circle_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">scale_factor</span><span class="o">*</span><span class="n">r</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">circle_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">scale_factor</span><span class="o">*</span><span class="n">r</span><span class="p">,</span>
                    <span class="n">circle_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">scale_factor</span><span class="o">*</span><span class="n">r</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="create_example_graph">
<a class="viewcode-back" href="../../embed_graph.html#ect.embed_graph.create_example_graph">[docs]</a>
<span class="k">def</span> <span class="nf">create_example_graph</span><span class="p">(</span><span class="n">centered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">center_type</span><span class="o">=</span><span class="s1">&#39;min_max&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to create an example ``EmbeddedGraph`` object. Helpful for testing. If ``centered`` is True, the coordinates are centered using the center type given by ``center_type``, either ``mean`` or ``min_max``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        EmbeddedGraph: An example ``EmbeddedGraph`` object.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">EmbeddedGraph</span><span class="p">()</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">centered</span><span class="p">:</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">set_centered_coordinates</span><span class="p">(</span><span class="n">center_type</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">graph</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Example usage of the EmbeddedGraph class</span>

    <span class="c1"># Create an instance of the EmbeddedGraph class</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">EmbeddedGraph</span><span class="p">()</span>

    <span class="c1"># Add vertices with their coordinates</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>

    <span class="c1"># Add edges between vertices</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">)</span>

    <span class="c1"># Get coordinates of a vertex</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Coordinates of A: </span><span class="si">{</span><span class="n">coords</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># Set new coordinates for a vertex</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">set_coordinates</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_coordinates</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;New coordinates of A: </span><span class="si">{</span><span class="n">coords</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># Get the bounding box of the vertex coordinates</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_bounding_box</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Bounding box: </span><span class="si">{</span><span class="n">bbox</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, MunchLab.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXX-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-XXXXXXX-1', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>