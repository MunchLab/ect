{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " # Tutorial : ECT for embedded graphs\n",
    "\n",
    "\n",
    "\n",
    " This jupyter notebook will walk you through using the `ect` package to compute the Euler characteristic transform of a 2D embedded graph. This tutorial assumes you already know what an ECT is; see [this paper](https://arxiv.org/abs/2310.10395) for a more thorough treatment of details."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from ect import ECT, EmbeddedGraph\n",
    "from ect.utils.examples import create_example_graph\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import networkx as nx\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " ## Constructing the embedded graph\n",
    "\n",
    "\n",
    "\n",
    " We assume our input is an undirected graph $G$ with an embedding in 2D given by a map on the vertices $f: V(G) \\to \\mathbb{R}^2$. A graph can be constructed as follows.\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Construct an example graph\n",
    "# Note that this is the same graph that is returned by:\n",
    "# G = create_example_graph()\n",
    "\n",
    "G = EmbeddedGraph()\n",
    "\n",
    "G.add_node(\"A\", [1, 2])\n",
    "G.add_node(\"B\", [3, 4])\n",
    "G.add_node(\"C\", [5, 7])\n",
    "G.add_node(\"D\", [3, 6])\n",
    "G.add_node(\"E\", [4, 3])\n",
    "G.add_node(\"F\", [4, 5])\n",
    "\n",
    "G.add_edge(\"A\", \"B\")\n",
    "G.add_edge(\"B\", \"C\")\n",
    "G.add_edge(\"B\", \"D\")\n",
    "G.add_edge(\"B\", \"E\")\n",
    "G.add_edge(\"C\", \"D\")\n",
    "G.add_edge(\"E\", \"F\")\n",
    "\n",
    "G.plot()\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " The coordinates of all vertices, given as a dictionary, can be accessed using the `coord_matrix` attribute."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "G.coord_matrix\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " Because of the rotational aspect of the ECT, we often want our graph to be centered, so you can use the `center_coordinates` method shift the graph to have the average of the vertex coordinates be 0. Note that this does overwrite the coordinates of the points."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "G.center_coordinates(center_type=\"mean\")\n",
    "print(G.coord_matrix)\n",
    "G.plot()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " To get a bounding radius we can use the `get_bounding_radius` method."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# This is actually getting the radius\n",
    "r = G.get_bounding_radius()\n",
    "print(f\"The radius of bounding circle centered at the origin is {r}\")\n",
    "\n",
    "# plotting the graph with it's bounding circle of radius r.\n",
    "G.plot(bounding_circle=True)\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " We can also rescale our graph to have unit radius using `scale_coordinates`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "G.scale_coordinates(radius=1)\n",
    "G.plot(bounding_circle=True)\n",
    "\n",
    "r = G.get_bounding_radius()\n",
    "print(f\"The radius of bounding circle centered at the origin is {r}\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "myect = ECT(num_dirs=16, num_thresh=20)\n",
    "\n",
    "# The ECT object will automatically create directions when needed\n",
    "print(f\"Number of directions: {myect.num_dirs}\")\n",
    "print(f\"Number of thresholds: {myect.num_thresh}\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " We can set the bounding radius as follows. Note that some methods will automatically use the bounding radius of the input `G` if not already set. I'm choosing the radius to be a bit bigger than the bounding radius of `G` to make some better pictures."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "myect.set_bounding_radius(1.2 * G.get_bounding_radius())\n",
    "\n",
    "print(f\"Internally set radius is: {myect.bound_radius}\")\n",
    "print(f\"Thresholds chosen are: {myect.thresholds}\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " If we want the Euler characteristic curve for a fixed direction, we use the `calculate` function with a specific angle. This returns an ECTResult object containing the computed values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "result = myect.calculate(G, theta=np.pi / 2)\n",
    "print(f\"ECT values for direction pi/2: {result[0]}\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " To calculate the full ECT, we call the `calculate` method without specifying theta. The result returns the ECT matrix and associated metadata."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "result = myect.calculate(G)\n",
    "\n",
    "print(f\"ECT matrix shape: {result.shape}\")\n",
    "print(f\"Number of directions: {myect.num_dirs}\")\n",
    "print(f\"Number of thresholds: {myect.num_thresh}\")\n",
    "\n",
    "# We can plot the result matrix\n",
    "result.plot()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " ## SECT\n",
    "\n",
    "\n",
    "\n",
    " The Smooth Euler Characteristic Transform (SECT) can be calculated from the ECT. Fix a radius $R$ bounding the graph. The average ECT in a direction $\\omega$ defined on function values $[-R,R]$ is given by\n",
    "\n",
    " $$\\overline{\\text{ECT}_\\omega} = \\frac{1}{2R} \\int_{t = -R}^{R} \\chi(g_\\omega^{-1}(-\\infty,t]) \\; dt. $$\n",
    "\n",
    " Then the SECT is defined by\n",
    "\n",
    " $$\n",
    "\n",
    " \\begin{matrix}\n",
    "\n",
    " \\text{SECT}(G): & \\mathbb{S}^1 & \\to & \\text{Func}(\\mathbb{R}, \\mathbb{Z})\\\\\n",
    "\n",
    " & \\omega & \\mapsto & \\{ t \\mapsto \\int_{-R}^t \\left( \\chi(g_\\omega^{-1}(-\\infty,a]) -\\overline{\\text{ECT}_\\omega}\\right)\\:da \\}\n",
    "\n",
    " \\end{matrix}\n",
    "\n",
    " $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " The SECT can be computed from the ECT result:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sect = result.smooth()\n",
    "\n",
    "sect.plot()\n"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": 3
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
